# Нумератор Option
***
Нумератор `Option`, он же отдельный тип, позволяет реализовать достаточно распространённое явление, а именно случай когда переменная может быть *чем-то* или *ничем*. 

Например, если мы запросим первый элемент из некоторого списка, то мы получим некоторое значение. Но если данный список пуст, то запросив первый элемент мы получим "ничего". В языках имеющих строгую систему типов, нужно жестко перечислить все возможные исходы.

В отличии от других языков программирования Rust не имеет такой вещи как `null`. `null` - это значение которое обозначает, что никакого значения нету. Проблемы с `null` происходят когда мы пытаемся использовать `null`-значение как значение которое, всё-таки, имеет некоторое значение.

Реализация в Rust
```rust
enum Option<T> {
	None,
	Some(T),
}
```

Нумератор `Option<T>` столь полезен, что он включён в Prelude, а значит мы можем использовать варианты `Some()` и `None` напрямую без префикса `Option::`.

Примеры использования `Option` значений для содержания числовых типов и строчных типов.

```rust
	let some_number = Some(13);
	let some_char = Some('e');
	
	let absent_number: Option<i32> = None;
```

Тип переменной `some_number` является типом `Option<i32>`, а тип `some_char` будет `Option<char>`, это разные типы. Компиллятор может распознать значение внутри варианта `Some` так как мы уточнили значение внутри его. Для переменной `absent_number` нам необходимо указать "руками" тип `None`.

Когда мы имеем значение `Some`, мы знаем что значение действительно и содержиться внутри `Some`. Когда мы имеем `None` значение, то в некотором смысле мы получаем то же поведение что и при использовании `null`.

Разница в том, что типы `Option<T>` и `T` (произвольный тип) являются разными типами, и компиллятор не позволит нам использовать значения `Option<T>` так если бы они были определённо действительными значениями. 
Например
```rust
	let x: i8 = 5;
	let x: Option<i8> = Some(5);
	
	let sum = x + y;
```

в этом случае мы получим ошибку при попытке скомилировать этот код, а именно мы не можем складывать между собой значения типа `i8` и `Option<i8>`. Компилятор заставит нас в случае с `Option<T>` рассмотреть и определить поведение перед тем чтобы как-то использовать значение.

Другими словами, нам нужно сконвертировать тип `Option<T>` в `T` перед тем как мы сможем выполнять с типом `T` операции.
***
#### Линки
- [[Prelude]],
- [[Дженерики в Rust]],
- [[Типы данных в Rust]],
- [[Enum в Rust]],
#### Тэги
 #Программирование/Rust 
#### Источники
1. https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html