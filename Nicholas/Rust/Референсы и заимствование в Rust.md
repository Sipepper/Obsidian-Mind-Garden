# Референсы и заимствование в Rust
#### Референсы
Рассмотрим пример, из-за которого вводится понятие *референса*.

Чтобы передать значение переменной но не передать владение, используется следующий "костыль":
```rust
fn main() {
    let s1 = String::from("hello");
    
    let (s2, len) = calculate_length(s1);
    
    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() возвращает длину строки

    (s, length)
}

```
Поэтому существуют *референсы*, чем то напоминающие указатели, по сути это путь по которому мы можем получить данные хранящиеся в переменной. В отличии от указателей, референсы *всегда* указывают на действительные значения определённого типа.

Реализация кода выше, используя референсы:
```rust
fn main() {
    let s1 = String::from("hello");
    
    let len = calculate_length(&s1);
    
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}

```
Сразу замечаем что таплов и обьявление новых переменных больше нету. Также важно то что мы передаём функциям переменные и оглашаем типы ставя амперсант(`&`) перед ними. Эти амперсанты как раз и указывают на то что мы используем референсы.
![[Pasted image 20220910152022.png]]
Более конкретно, рассмотрим вызов следующей функции
```rust
	let s1 = String::from("hello");
	
	let len = calculate_length(&s1);
```
Код `&s1` передаёт функции лишь значение переменной `s1` но не владение на неё. Так как функция не владеет данной переменной то её значение не будет сброшено когда референс перестанет использоваться.

Подобным образом мы указываем референс на тип параметра в функции, когда хотим получить только значение переменной но не владеть ею.
```rust
fn calculate_length(s: &String) -> usize { // s - референс на тип String
	s.len()
} // Здесь s выходит из области видимости. Но так как эта функция не 
  // владеет данной переменной то её значение не сбрасывается
```
Область видимости в которой переменная `s` является действительной совпадает с областью видимости параметра функции.

#### Заимствование
Процесс создания референса называется *заимствованием*. Как и в реальной жизни, если кто-то чем-то владеет то мы можем взять на время себе то чем этот человек владеет. Как только мы готовы мы должны вернуть вещь назад. Мы не владеем этой вещью на период заимствования, а поэтому не можем её поменять.

Таким образом, при попытке изменить переменную, данные которой мы заимствуем, мы получим ошибку:
```rust
fn main() {
    let s = String::from("hello");
     
    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}

```
Референсы как и переменные по умолчанию являются неизменяемыми.

#### Изменяемые референсы
Чтобы мы имели возможность как-то работать с данными переменной которые мы заимствуем, существуют *изменяемые* референсы, таким образом код выше(в разделе о заимствовании) будет работать если его немного видоизменить:
```rust
fn main() {
	let mut s = String::from("hello");
	
	change(&mut s);
}

fn change(some_string: &mut String) {
	some_string.push_str(", world");
}
```
Сначала мы должны сделать переменную на которую мы делаем референс изменяемой. Далее мы создаём изменяемый референс `&mut s` там где мы вызываем функцию `change`, и изменяем типы параметров принимаемых функцией на изменяемые референсы `some_string: &mut String`. Это явно указывает на то что функция `change` изменит значение из переменной которые она заимствует.
***
**Важно!**
Одновременно в одной области видимости может существовать только один изменяемый референс на меременную!
***
Поэтому следующий код не скомпилится:
```rust
fn main() {
    let mut s = String::from("hello");
    
    let r1 = &mut s;
    let r2 = &mut s;
    
    println!("{}, {}", r1, r2);
}

```
Первое изменяемое заимствование происходит в переменной `r1` и должно существовать пока не будет использовано в `println!`, но мы попытались создать изменяемый референс в `r2` который ссылается и пытается изменить те же данные что и `r1`. 

Данное ограничение в Rust присутствует чтобы упразнить *Дата рейсы*("гонки за данными"), т.е. ситуации когда 
- Два или более указателя имеют доступ к данным одновременно.
- Как минимум один из указателей используется чтобы перезаписать данные.
- Нету механизма который бы синхронизировал доступ к данным.
Дата рейсы зачастую приводят к неопределённому поведению программы в рантайме и их очень сложно отследить и пофиксить.
#### Взаимодействие изменяемых и неизменяемых референсов
Одновременно не могу существовать и изменяемые и неизменяемые референсы, так как те функции которые используют неизменяемый референс "ожидают" что данные никак при этом не изменятся. Таким образом следующий код выдаст ошибку:
```rust
fn main() {
    let mut s = String::from("hello");
	
    let r1 = &s; // нет проблем
    let r2 = &s; // нет проблем
    let r3 = &mut s; // смэрть
	
    println!("{}, {}, and {}", r1, r2, r3);
}

```
Заметим что референс действителен с того момента как мы его обьявили и до того момента когда он был последний раз использован. Например, этот код скомпилируется
```rust
fn main() {
    let mut s = String::from("hello");
	
    let r1 = &s; // нет проблем
    let r2 = &s; // нет проблем
    println!("{} and {}", r1, r2);
    // переменные r1 и r2 после этого момента не используются
	
    let r3 = &mut s; // нет проблем
    println!("{}", r3);
}
```
Время жизни неизменяемых референсов `r1` и `r2` заканчивается после `println!`, где они последний раз используются, что происходит до создания изменяемого референса `r3`.
#### Висячие референсы
В языках программирования которые используют указатели, зачастую появляется проблема *висячих указателей* - указателей которые указывают на место в памяти которое, скорее всего, уже отдано кому-то другому.

В расте, в отличии от других языков, такой проблемы нету, а именно; компилятор не позволит нам создать *висячий референс*. Если мы имеем референс на некоторые данные, компилятор позаботится о том что данные не выйдут из области видимости до того как это сделает референс.

Попробуем создать такой висячий указатель:
```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```
Этот код приведёт к ошибке
`this function's return type contains a borrowed value, but there is no value for it to be borrowed from`
Рассмотрим конкретнее что происходит на каждой стадии выполнения кода
```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle возвращает референс на Строку
	
    let s = String::from("hello"); // s - новая Строка
	
    &s // мы возвращаем референс на Cтроку s
} // Здесь s выходит из области видимости и сбрасывается.
  // Смэрть!
```
Так как `s` была создана внутри функции `dangle` то когда код внутри этой функции будет выполнен, память под переменную `s` будет освобождена. 
Но после этого мы пытаемся вернуть референс на эту переменную. В данном случае референс будет указывать на недействительную Строку. Поэтому раст не позволит нам это сделать.

Но есть способ как сделать код выше рабочим:
```rust
fn no_dangle() -> String {
	let s = String::from("hello");
	
	s
}
```
#### Линки
 [[Типы данных в Rust]],
 [[Ownership in Rust]],
 [[Типы данных в Rust]],
 [[Функции в Rust]],
 [[Области видимости в Rust]],
 [[How to define a variable in Rust]],
 
#### Тэги
 #Программирование/Rust 
#### Источники
1. https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html