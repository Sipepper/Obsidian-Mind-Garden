***
###### tags: #Программирование/Rust  
***
Допустим, мы хотим создать функцию которая будет принимать тип `Option<i32>` и если внутри есть некоторое значение, то прибавлять единицу к этому значению. Если значения внутри нету, функция должна вернуть значение `None` и не должна выполнять никаких операций.

Такую функцию легко создать с помощью `match`, и выглядеть она будет следующим образом:
```rust
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```
Рассмотрим каждый вызов функции `plus_one` подробнее. Когда мы вызвали функцию `plus_one(five)`, переменная `x` внутри функции `plus_one` будет иметь значение `Some(5)`. Далее мы сравниваем это значение с каждой рукой `match`.
```rust
		None => None,
```
Значение `Some(5)` не соответсвует паттерну `None`, а значит мы переходим к следующей руке
```rust
		Some(i) => Some(i+1),
```
Значение `Some(5)` действительно соответствует `Some(i)` Так как они имеют одинаковый тип. `i` привязывается к значению которое хранится в `Some`, а значит `i` принимает значение `5`. После этого выполняется код в руке, а значит мы прибавляем `1` к значению `i` и создаём новое значения типа `Some` с `6` внутри.

Рассмотрим теперь второй вызов функции `plus_one`, где `x` есть `None`. Мы попадаем в `match` и сравниваем это значение первой рукой.
```rust
		None => None,
```
Значение подходит. А значит нет никакого значения к которому можно прибавить единицу, таким образом программа завершает свою работу и возвращает значение `None`. Так как первая рука подошла, других сравнений произведено небыло.
***
#### Keywords
- [[Нумератор Option]],
- [[match в Rust]],
- [[Функции в Rust]],
- [[How to define a variable in Rust]],
#### Possibly related
- 
***
#### Sources:
1. https://doc.rust-lang.org/book/ch06-02-match.html