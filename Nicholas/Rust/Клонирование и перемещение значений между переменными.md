# Клонирование и перемещение значений между переменными
#### Перемещение(Move)
Часто сразу несколько переменных могут взаимодествовать с одной и той же информацией(значением) по разному. Например
```rust
	let x = 5;
	let y = x;
```
Мы присваиваем переменной `x` значение `5`. После этого мы делаем копию значения которое содержит переменная `x` и присваиваем его к `y`. Это действительно происходит, так как числа являются простым типом данных с известным фиксированым размером, т.е. хранятся в стэке.

Рассмотрим теперь случай для типа `String`:
```rust
	let s1 = String::from("zdarou");
	let s2 = s1;
```
Вроде всё должно работать также, но на самом деле нет, для этого нужно разобраться как работает тип `String`. 
Тип `String` состоит из трёх частей
![[Pasted image 20220903204911.png]]
Слева на картинке: Указатель(Pointer) на участок памяти где находится содержимое строки, длину строки и вместимость*, эта группа данных содержится в стэке. 

Справа на картинке: Память в Куче(heap) в которой находится содержимое строки. 
- Длина отвечает за то сколько памяти в байтах "содержимое строки" использует в данный момент. 
- Вместимость отвечает за общее количество памяти в байтах которое строка получила от Аллокатора.

Когда мы присваиваем `s1` к `s2`, тип данных `String` копируется, в том смысле что копируется указатель, длина и вместимость которые хранятся в стэке. Мы не копируем данные из кучи на которую ссылается указатель.
![[Pasted image 20220903204936.png]]
Если бы при прирсваивании ещё и копировались данные в куче, то это было бы очень затратно по производительности в рантайме. Особенно если данные в куче увесистые.

Так как Rust автоматически вызывает функцию `drop` когда переменная выходит из области видимости и чистит память в куче для этой переменной, то если у нас указатели в обеих переменных указывают на один и тот же кусок памяти, то при освобождении случится *double free* ошибка, которая может привести к ошибкам с памятью и уязвимостям.

Чтобы избавиться от *double free*, в Rust после строки `let s2 = s1` переменная `s1` больше не считается действительной. Таким образом, компилятору не нужно ничего освобождать когда переменная `s1` выходит из области видимости. 

Таким образом, подобные конструкции называют *перемещением* данных из одной переменной в другую:
![[Pasted image 20220903205934.png]]
Это действительно решает проблему, так как если только переменная `s2` будет действительной, когда она выйдет из области видимости, память освободиться только для неё.

#### Клонирование(Clone)
Если нам нужно скопировать в другую переменную не только данные которые хранятся в стэке но и те которые хранятся в куче, то мы можем использовать метод `.clone()`
```rust
	let s1 = String::from("qq");
	let s2 = s1.clone();
	
	println!("s1 = {}, s2 = {}", s1, s2);
```

#### Линки
- [[How to define a variable in Rust]],
- [[Типы данных в Rust]],
- [[Стэк и куча]],
- [[Строка в Rust]],
- [[Выделение памяти в Rust]],
- [[Области видимости в Rust]],
- [[Методы в Rust]]
#### Тэги
 #Программирование/Rust 
#### Источники
1. https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html