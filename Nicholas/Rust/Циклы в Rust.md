# Циклы в Rust
В Rust циклы реализованы в трёх видах: 
1. `loop` - мы выходим из цикла только в тот момент когда мы явно на это указываем
2. `while` - мы бежим по циклу пока справедливо некоторое условие
3. `for` - мы бежим по некоторому набору элементов.
#### Loop
##### Бесконечный цикл
Если не указать `break` прерывание цикла `loop` то данный цикл будет идти вечно(пока не будет прекращён выключением приложения).
Реализация:
```rust
fn main() {
	loop {
		println!("puk");
	}
}
```
Бесконечный цикл можно прервать через терминал с помошью `ctrl+c`.
С помощью ключевого слова `continue` мы можем сразу игнорируя остальной код перейти к следующей итерации.
##### Loop возвращающий значения
Чтобы получить некоторое значение на определённой итерации нужно после ключевого слова `break` добавить переменную значение которой мы хотим вернуть.
Реализация:
```rust
fn main() {
	let mut counter = 0;
	
	let result = loop {
		counter += 1;
		
		if counter == 12 {
			break counter * 2;
		}
	};
	
	println!("Counter,{result}");
}
```
Перед `loop` мы задаём изменяемую переменную `counter` и присваиваем ей значение `0`. Далее мы задаём переменную `result` чтобы присвоить её значение которое мы получим из цикла `loop`. На каждой итерации мы прибавляем к переменной `counter` единицу и потом мы проверяем является ли `counter` двенадцати. Далее мы указываем значение `counter * 2` после ключевого слова `break`. 
##### Вложенные циклы Loop
Если мы имеем вложенные циклы `loop` то `break` и `continue` будут применятся к ближайшему циклу(innermost). Если же мы хотим прекратить какой-то внешний цикл, или определённый цикл, то мы можем сделать это с помощью одной кавычки `'` перед названием цикла и указав название с кавычкой после ключевого слова `break`/`continue`.
Реализация: 
```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }
        
        count += 1;
    }
    println!("End count = {count}");
}

```
Внешний луп имеющий название `'counting_up` будет "считать" от 0 до 2. Внутренний луп без названия "считает" от 10 до 9. Первый `break` в котором не указано называние выйдет только из внутреннего лупа. С другой стороны выражение `break 'counting_up;` выходит из внешнего цикла, в коммандной строке мы получим следующий результат
```
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
```
#### Цикл While
Для того чтобы упразнить лишний код используя `if`,`else` или `break` внутри `loop` в Rust существует цикл `while` который прерывается в случае выполнения некоторого условия.
Реализация:
```rust
fn main() {
	let mut number = 4;
	
	while number != 0 {
		println!("{}",number);
		
		number -= 1;
	}
	
	println!("Startuem");
}
```
#### Цикл For
Чтобы пробежаться по некоторому набору элементов, например множеству(array), мы можем применить и цикл `while`
Реализация: 
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);
        
        index += 1;
    }
}
```
Но такая реализация не является правильной, так как если мы уменьшим количество элементов в множестве `a` но не изменим условие которое применяется к индексу, то код скорее всего даже не скомпилится. Да и данная реализация медленнее так как компилятор добавляет в рантайме код который проверяет не вылез ли индекс за пределы на каждой итерации.

Для таких случаев мы должны использовать цикл `for`.
Реализация:
```rust
fn main() {
	let a = [12,24,36,48,60];
	
	for number in a {
		println!("counting {number}");
	}
}
```
Такая реализация вызывает меньше багов, не нужно беспокоиться за изменение размера массива данных.
#### Линки
 [[Задание переменных в Rust]],
 [[If в Rust]],
 [[Типы данных в Rust]]
#### Тэги
 #Rust 
#### Источники
1. https://doc.rust-lang.org/book/ch03-05-control-flow.html