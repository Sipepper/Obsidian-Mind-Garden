# Срезы в Rust
***
>Тип срез(Slice) в Rust позволяет делать референс на последовательность элементов в каком-то наборе вместо всего набора.

Чтобы понять для чего и как определяются срезы рассмотрим задачу: "Нужно создать функцию которая вернёт первое слово из строки, если вся строка является одним словом то нужно вернуть строку."

Реализация без использования срезов:
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();
	
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
	
    s.len()
}

fn main() {}
```
Сначала мы переводим строку в массив байтов с помощю метода `.as_bytes`, так как мы хотим пройтись по каждому элементу строки.
```rust
	let bytes = s.as_bytes();
```
Далее мы создаём итерируемый объект с помощью метода `.iter()`. 
```rust
	for (i, &item) in bytes.iter().enumerate() {
```
Метод `.enumerate()` возвращает тапл в котором, на первом месте индекс обьекта а на втором референс на этот обьект. 

Далее внутри цикла `for` мы ищем такой набор байт которые являются "пробелом" с помощью байт литерала `b' '`.
```rust
		if item == b' ' {
			return i;
		}
```
И соответсвенно в конце кода мы возвращаем длину строки если для всех элементов в цикле не было выполнено условие.
```rust
	s.len()
```
Мы получили способ нахождения индекс конца первого слова в конце, но есть проблема: 
>*функция возвращает значение которое, строго говоря, не привязано к строке*, 

т.е. если в будущем строка изменится то значение нашей функции останется прежним.
```rust
fn main() {
	let mut s = String::from("hello zdarow");
	
	let word = first_word(&s); // word присвоится значение 5
	
	s.clear(); // мы очищаем строку, теперь она равна ""
	
	// переменная word до сих пор имеет значение 5 здесь, но больше нету
	// строки с которой мы могли бы сопоставить это значение
}
```
Эта программа без проблем компиллится даже если мы очистим строку перед тем как присвоим переменной `word` значение. Всё становится ещё хуже если мы, например, захотим создать ещё одну функцию которая теперь будет искать второе слово. Нам придётся отслеживать уже индекс начала и конца, что при сложных типах данных вызывает много головной боли. К счастью в Rust есть решение данной проблемы.
***
#### Срезы строки
>*Срез строки* является референсом на часть Строки

и выглядит следующим образом:
```rust
	let s = String::from("hello zdarow");
	
	let hello = &s[0..5];
	let zdarow = &s[6..12];
```
Когда мы создаём строку, в квадратных скобках мы указываем с какого по какой индекс(не включительно) мы хотим сделать срез.

Под капотом, тип срез хранит в себе начальную позицию и длину срезу.
![[Pasted image 20220919202921.png]]

С помощью синтаксиса `..` мы можем при надобности опустить либо начальный либо конечный индекс среза, либо вообще вернуть всю строку
```rust
	let s = String::from("hello");
	
	let slice1 = &s[0..2];
	let slice2 = &s[..2];
	// срезы slice1 и slice2 совпадают
	let slice3 = &s[0..];
	let slice4 = &s[..];
```
Также можно передать в индекс какую-то числовую переменную
```rust
	let s = String::from("hellow");
	let len = s.len();
	
	let slice5 = &s[0..len];
```
**Важно!**
> Индексы в срезе строки должны происходить на правильных границах символов в UTF-8 кодировке. Иначе произойдёт ошибка.

Реализация функции `first_word` с помощью срезов:
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();
	
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
	
    &s[..]
}

fn main() {}
```

Мы получаем индекс конца слова также как и раньше, по нахождению первого пробела. Когда мы находим пробел, мы возвращаем срез строки.

Теперь когда мы вызываем функцию `first_word` мы получаем значение которое привязано к значению строки.

Логическая ошибка которая была когда мы не использовали срезы, очищая строку после вызова функции `first_word`, в случае срезов будет невозможна; вернее её поймает компилятор.

```rust
fn main() {
	let mut s = String::from("hello world");
	
	let word = frist_word(&s);
	
	s.clear(); // смэрть!
	
	println!("the first word is: {}", word);
}
```
Вот что на это скажет компиллятор
```
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error

```

Так как методу `.clear()` нужно укоротить Строку, то ему нужно получить изменяемый референс. Макрос `println!` после вызова метода `.clear()` использует референс в `word`, а значит неизменяемый референс должен быть действительным в этот момент. Rust не позволяет одновременно существовать изменяемому референсу в `clear` и неизменяемому референсу в `word`.
#### Срезы строк в качестве параметра функции
Если мы хотим чтобы функция могла принимать в себя и референс на срез строки, а не только строки. То мы должны указать тип `&str` в типах параметров функции, таким образом наша функция `first_word` сможет работать не только со строками, но и со строчными литералами(которые также являются срезами).
```rust
fn first_word(s: &str) -> &str {
```
#### Другие виды срезов
Рассмотрим массив чисел
```rust
let a = [1,2,3,4,5];
```
Мы можем выделить определённую часть данного массива с помощью срезов
```rust
let a = [1,2,3,4,5];

let slice = &a[1..4];

assert_eq!(slice, &[2,3]);
```
Подобные срезы работают так же как и срезы строк. Срез выше будет иметь тип `&[i32]`.
***
#### Линки
- [[Итераторы в Rust]],
- [[Типы данных в Rust]],
- [[Байт литерал]],
- [[Функции в Rust]],
- [[Циклы в Rust]],
- [[Референсы и заимствование в Rust]],
- [[UTF-8 кодировка]],
#### Тэги
 #Rust 
 #Программирование 
#### Источники
1. https://doc.rust-lang.org/book/ch04-03-slices.html