# match в Rust
***
Конструкция `match` позволяет присваивать ряду значений разные значения или выполнение разного кода в зависимости от значения.

Рассмотрим на примере ценности разных монет:
```rust
enum Coin {
	Penny,
	Nickel,
	Dime,
	Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
	match coin {
		Coin::Penny => 1,
		Coin::Nickel => 5,
		Coin::Dime => 10,
		Coin::quarter => 25, 
	}
}

```

Мы задали функцию которая принимает в себя на входе неизвестную монету, определяет что это за монета и возвращает значение в центах.

Разберём реализацию подробнее:

Сначала мы указываем ключевое слово `match` ,после него идёт выражение, в нашем случае значение `coin`.

>В отличии от `if`, выражение после которого должно возвращать булевое значение, выражение же после `match` может возвращать любой тип данных. 

Далее "руки". Каждая рука состоит из двух частей: *паттерна* и некоторого кода. Здесь первая рука имеет паттерн в виде значения `Coin::Penny` и после этого стоит оператор `=>` который разделяет паттерн и код для выполнения. В данном случае код(выражение) которое выполняется это значение `1`. 

Когда выражение `match` выполняется, оно сравнивает значение на выходе с каждым из паттернов каждой руки, по порядку. Если паттерн совпадает со значением, то код соответствующий этому паттерну будет выполнятся. Если же нет, то выполнение переходит к следующей руке и т.д.

>Каждая рука разделяется запятой. Но это не обязательно если код будет заключен в фигурные скобки, т.е. область видимости.

```rust
fn value_in_cents(coin: Coin) -> u8 {
	match coin {
		Coin::Penny => {
			println!("Lucky penny!");
			1
		}
		Coin::Nickel => 5,
		Coin::Dime => 10,
		Coin::Quarter => 25,
	}
}
```

#### Паттерны привязанные к значениям
Удобной фишкой рук в `match` является то что они могут быть привязаны к частью значения с которым сравнивается паттерн. Таким образом мы можем доставать значения из вариантов нумераторов.

Рассмотрим пример, немного изменим вариант в нашем нумераторе `Coin` так чтобы он мог содержать некоторое значение. С 1999 до 2008 года, в Соединённых штатах выпускали особые четвертаки с изображением каждого из 50 штатов на одной из сторон. Никакая из других монет не получила подобные дизайны, так что только четвертаки могут иметь дополнительную ценность. Мы можем добавить эту информацию в наш `enum` изменив вариант `Quarter` так чтобы он включал значение `UsState` внутри себя
```rust
#[derive(Debug)]
enum UsState {
	Alabama,
	Alaska,
	//
}

enum Coin {
	Penny,
	Nickel,
	Dime,
	Quarter(UsState),
}
```

В выражении `match` мы добавили переменную `state` в паттерн который сравнивает значение варианта `Coin::Quarter`. Когда `Coin::Quarter` подходит, переменная `state` привязывается к значению штата этого четвертака. Тогда мы пожем использовать `state` в коде для этой руки, например так:
```rust
fn value_in_cents(coin: Coin) -> u8 {
	match coin {
		Coin::Penny => 1,
		Coin::Nickel => 5,
		Coin::Dime => 10,
		Coin::Quarter(state) => {
			println!("State quarter from {:?}!",state);
			25
		}
	}
}

```
Если мы вызовем `value_in_cents(Coin::Quarter(UsState::Alaska))`, то `coin` будет иметь значение `Coin::Quarter(UsState::Alaska)`. Когда мы сравним это значение из каждым из рук, ниодно из них не подойдёт пока мы не достигнем `Coin::Quarter(state)`.
***
#### Линки
- [[Утверждения и Выражения в Rust]],
- [[Scopes in Rust]],
- [[Enums in Rust]]
#### Тэги
 #Programming/Rust 
#### Источники
1. https://doc.rust-lang.org/book/ch06-02-match.html